package com.mycompany.View;

import com.mycompany.DAO.CheckListAtendimentoDAO;
import com.mycompany.DTO.CheckListAtendimentoDTO;
import com.mycompany.Util.UpperCaseDocumentFilter;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.sql.Date;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import javax.swing.JOptionPane;
import javax.swing.Timer;
import javax.swing.table.DefaultTableModel;
import javax.swing.text.AbstractDocument;

/**
 *
 * @author Giuliano Vianna
 */
public class CheckListAtendimentoView extends javax.swing.JFrame {

    /**
     * Creates new form CheckListAtendimentoView
     */
    public CheckListAtendimentoView() {
        initComponents();
        
        // Aplicar o filtro UpperCaseDocumentFilter aos campos de texto
        aplicarFiltroMaiusculas();

        popularTabela();

        txtId.setVisible(false);

        Timer timer = new Timer(1000, new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                atualizarDataHora();
            }
        });
        timer.start(); // Inicia o timer
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        txtCliente = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        txtEmpresa = new javax.swing.JTextField();
        txtDescricao = new javax.swing.JTextField();
        cbxStatus = new javax.swing.JComboBox<>();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        tabelaCheckList = new javax.swing.JTable();
        jPanel2 = new javax.swing.JPanel();
        btnNovo = new javax.swing.JButton();
        btnSalvar = new javax.swing.JButton();
        btnEditar = new javax.swing.JButton();
        btnAtualizar = new javax.swing.JButton();
        btnExcluir = new javax.swing.JButton();
        btnCancelar = new javax.swing.JButton();
        btnAdTarefa = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JSeparator();
        lbHora = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        rdbFiltro = new javax.swing.JRadioButton();
        txtId = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("CheckList de Atendimentos");
        setResizable(false);

        jLabel1.setFont(new java.awt.Font("Helvetica Neue", 0, 15)); // NOI18N
        jLabel1.setText("Cliente");

        txtCliente.setEditable(false);
        txtCliente.setBackground(new java.awt.Color(204, 204, 204));
        txtCliente.setFont(new java.awt.Font("Helvetica Neue", 0, 14)); // NOI18N
        txtCliente.setForeground(new java.awt.Color(51, 51, 51));

        jLabel2.setFont(new java.awt.Font("Helvetica Neue", 0, 15)); // NOI18N
        jLabel2.setText("Empresa");

        txtEmpresa.setEditable(false);
        txtEmpresa.setBackground(new java.awt.Color(204, 204, 204));
        txtEmpresa.setFont(new java.awt.Font("Helvetica Neue", 0, 14)); // NOI18N
        txtEmpresa.setForeground(new java.awt.Color(51, 51, 51));

        txtDescricao.setEditable(false);
        txtDescricao.setBackground(new java.awt.Color(204, 204, 204));
        txtDescricao.setFont(new java.awt.Font("Helvetica Neue", 0, 14)); // NOI18N
        txtDescricao.setForeground(new java.awt.Color(51, 51, 51));

        cbxStatus.setBackground(new java.awt.Color(204, 204, 204));
        cbxStatus.setFont(new java.awt.Font("Helvetica Neue", 0, 14)); // NOI18N
        cbxStatus.setForeground(new java.awt.Color(51, 51, 51));
        cbxStatus.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Selecione", "Cancelado", "Em Andamento", "Finalizado", "Pendente" }));
        cbxStatus.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cbxStatusActionPerformed(evt);
            }
        });

        jLabel4.setFont(new java.awt.Font("Helvetica Neue", 0, 15)); // NOI18N
        jLabel4.setText("Status");

        tabelaCheckList.setFont(new java.awt.Font("Helvetica Neue", 0, 14)); // NOI18N
        tabelaCheckList.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null},
                {null, null, null, null, null, null},
                {null, null, null, null, null, null},
                {null, null, null, null, null, null}
            },
            new String [] {
                "ID", "Cliente", "Empresa", "Status", "Descricão", "Data"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tabelaCheckList.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
        tabelaCheckList.setSelectionBackground(new java.awt.Color(204, 102, 255));
        tabelaCheckList.setShowGrid(true);
        jScrollPane1.setViewportView(tabelaCheckList);
        if (tabelaCheckList.getColumnModel().getColumnCount() > 0) {
            tabelaCheckList.getColumnModel().getColumn(0).setMinWidth(70);
            tabelaCheckList.getColumnModel().getColumn(0).setMaxWidth(70);
            tabelaCheckList.getColumnModel().getColumn(1).setMinWidth(200);
            tabelaCheckList.getColumnModel().getColumn(2).setMinWidth(300);
            tabelaCheckList.getColumnModel().getColumn(3).setMinWidth(200);
            tabelaCheckList.getColumnModel().getColumn(4).setMinWidth(350);
            tabelaCheckList.getColumnModel().getColumn(4).setPreferredWidth(410);
            tabelaCheckList.getColumnModel().getColumn(4).setMaxWidth(450);
            tabelaCheckList.getColumnModel().getColumn(5).setMinWidth(120);
        }

        jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        btnNovo.setBackground(new java.awt.Color(153, 0, 153));
        btnNovo.setFont(new java.awt.Font("Helvetica Neue", 0, 16)); // NOI18N
        btnNovo.setForeground(new java.awt.Color(255, 255, 255));
        btnNovo.setText("Novo");
        btnNovo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnNovoActionPerformed(evt);
            }
        });

        btnSalvar.setBackground(new java.awt.Color(153, 0, 153));
        btnSalvar.setFont(new java.awt.Font("Helvetica Neue", 0, 16)); // NOI18N
        btnSalvar.setForeground(new java.awt.Color(255, 255, 255));
        btnSalvar.setText("Salvar");
        btnSalvar.setEnabled(false);
        btnSalvar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSalvarActionPerformed(evt);
            }
        });

        btnEditar.setBackground(new java.awt.Color(153, 0, 153));
        btnEditar.setFont(new java.awt.Font("Helvetica Neue", 0, 16)); // NOI18N
        btnEditar.setForeground(new java.awt.Color(255, 255, 255));
        btnEditar.setText("Editar");
        btnEditar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnEditarActionPerformed(evt);
            }
        });

        btnAtualizar.setBackground(new java.awt.Color(153, 0, 153));
        btnAtualizar.setFont(new java.awt.Font("Helvetica Neue", 0, 16)); // NOI18N
        btnAtualizar.setForeground(new java.awt.Color(255, 255, 255));
        btnAtualizar.setText("Atualizar");
        btnAtualizar.setEnabled(false);
        btnAtualizar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAtualizarActionPerformed(evt);
            }
        });

        btnExcluir.setBackground(new java.awt.Color(153, 0, 153));
        btnExcluir.setFont(new java.awt.Font("Helvetica Neue", 0, 16)); // NOI18N
        btnExcluir.setForeground(new java.awt.Color(255, 255, 255));
        btnExcluir.setText("Excluir");
        btnExcluir.setEnabled(false);
        btnExcluir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnExcluirActionPerformed(evt);
            }
        });

        btnCancelar.setBackground(new java.awt.Color(153, 0, 153));
        btnCancelar.setFont(new java.awt.Font("Helvetica Neue", 0, 16)); // NOI18N
        btnCancelar.setForeground(new java.awt.Color(255, 255, 255));
        btnCancelar.setText("Cancelar");
        btnCancelar.setEnabled(false);
        btnCancelar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCancelarActionPerformed(evt);
            }
        });

        btnAdTarefa.setBackground(new java.awt.Color(153, 0, 153));
        btnAdTarefa.setFont(new java.awt.Font("Helvetica Neue", 0, 15)); // NOI18N
        btnAdTarefa.setForeground(new java.awt.Color(255, 255, 255));
        btnAdTarefa.setText("Ad. Tarefa");
        btnAdTarefa.setEnabled(false);
        btnAdTarefa.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAdTarefaActionPerformed(evt);
            }
        });

        lbHora.setFont(new java.awt.Font("Helvetica Neue", 0, 18)); // NOI18N
        lbHora.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lbHora.setText(".");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(14, 14, 14)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(btnAdTarefa, javax.swing.GroupLayout.DEFAULT_SIZE, 100, Short.MAX_VALUE)
                    .addComponent(btnCancelar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnExcluir, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnAtualizar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnEditar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnSalvar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(btnNovo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jSeparator1)
                    .addComponent(lbHora, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(16, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addComponent(lbHora)
                .addGap(18, 18, 18)
                .addComponent(btnNovo, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(btnSalvar, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(btnEditar, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(btnAtualizar, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(btnExcluir, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(btnCancelar, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 46, Short.MAX_VALUE)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(btnAdTarefa, javax.swing.GroupLayout.PREFERRED_SIZE, 64, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(35, 35, 35))
        );

        jLabel5.setFont(new java.awt.Font("Helvetica Neue", 0, 15)); // NOI18N
        jLabel5.setText("Descrição");

        rdbFiltro.setFont(new java.awt.Font("Helvetica Neue", 1, 15)); // NOI18N
        rdbFiltro.setText("Filtro");
        rdbFiltro.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdbFiltroActionPerformed(evt);
            }
        });

        txtId.setBackground(new java.awt.Color(204, 204, 204));
        txtId.setEnabled(false);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(txtId, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(txtCliente, javax.swing.GroupLayout.PREFERRED_SIZE, 187, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(txtEmpresa, javax.swing.GroupLayout.PREFERRED_SIZE, 187, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(18, 18, 18)
                                        .addComponent(rdbFiltro))
                                    .addComponent(cbxStatus, javax.swing.GroupLayout.PREFERRED_SIZE, 139, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(534, 534, 534))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(txtDescricao)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED))))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jScrollPane1)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)))
                        .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(24, 24, 24))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(35, 35, 35)
                        .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(txtId, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(3, 3, 3)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel2)
                            .addComponent(jLabel4)
                            .addComponent(rdbFiltro)
                            .addComponent(jLabel1)
                            .addComponent(jLabel5))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                            .addComponent(cbxStatus, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtDescricao, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtEmpresa, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(txtCliente, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane1)))
                .addGap(23, 23, 23))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnAdTarefaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAdTarefaActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_btnAdTarefaActionPerformed

    private void btnSalvarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSalvarActionPerformed

        cadastrarChecklist();
    }//GEN-LAST:event_btnSalvarActionPerformed

    private void btnEditarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnEditarActionPerformed

        editarCheckList();
    }//GEN-LAST:event_btnEditarActionPerformed

    private void btnNovoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNovoActionPerformed

        habilitarBotoes(false, true, false, false, false, true);
        habilitarCampos(true, true, true);
        txtCliente.requestFocus();
    }//GEN-LAST:event_btnNovoActionPerformed

    private void btnCancelarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCancelarActionPerformed

        habilitarBotoes(true, false, true, false, false, false);
        limparCampos();
    }//GEN-LAST:event_btnCancelarActionPerformed

    private void btnAtualizarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAtualizarActionPerformed

        atualizarCheckList();
    }//GEN-LAST:event_btnAtualizarActionPerformed

    private void btnExcluirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnExcluirActionPerformed

        excluirCheckList();
    }//GEN-LAST:event_btnExcluirActionPerformed

    private void cbxStatusActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cbxStatusActionPerformed

        regraFiltro();
    }//GEN-LAST:event_cbxStatusActionPerformed

    private void rdbFiltroActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdbFiltroActionPerformed

        regraFiltro();
    }//GEN-LAST:event_rdbFiltroActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(CheckListAtendimentoView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(CheckListAtendimentoView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(CheckListAtendimentoView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(CheckListAtendimentoView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new CheckListAtendimentoView().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnAdTarefa;
    private javax.swing.JButton btnAtualizar;
    private javax.swing.JButton btnCancelar;
    private javax.swing.JButton btnEditar;
    private javax.swing.JButton btnExcluir;
    private javax.swing.JButton btnNovo;
    private javax.swing.JButton btnSalvar;
    private javax.swing.JComboBox<String> cbxStatus;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JLabel lbHora;
    private javax.swing.JRadioButton rdbFiltro;
    private javax.swing.JTable tabelaCheckList;
    private javax.swing.JTextField txtCliente;
    private javax.swing.JTextField txtDescricao;
    private javax.swing.JTextField txtEmpresa;
    private javax.swing.JTextField txtId;
    // End of variables declaration//GEN-END:variables

    /**
     * Atualiza a label de hora com a hora atual formatada.
     * <p>
     * Este método obtém a hora atual, formata-a conforme um padrão específico
     * (HH:mm:ss) e atualiza uma label na interface gráfica com essa hora
     * formatada. É útil para exibir a hora atualizada em tempo real na
     * interface de usuário.
     * </p>
     * <p>
     * A label {@code lbHora} é atualizada com o texto da hora formatada. Esse
     * método pode ser chamado repetidamente, por exemplo, através de um timer,
     * para manter a hora exibida sempre atualizada.
     * </p>
     */
    public void atualizarDataHora() {
        // Cria um formatador para a hora no formato HH:mm:ss
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("HH:mm:ss");

        // Obtém a hora atual
        LocalDateTime agora = LocalDateTime.now();

        // Formata a hora atual
        String dataHoraFormatada = dtf.format(agora);

        // Atualiza o texto da label lbHora com a hora formatada
        lbHora.setText(dataHoraFormatada);
    }

    /**
     * Cadastra um novo checklist no banco de dados e atualiza a tabela na
     * interface gráfica.
     * <p>
     * Este método coleta os dados da interface gráfica, cria um novo objeto
     * {@link CheckListAtendimentoDTO}, define os valores para esse objeto e
     * utiliza um objeto {@link CheckListAtendimentoDAO} para inserir esses
     * dados no banco de dados.
     * </p>
     * <p>
     * Após o cadastro do novo checklist, a tabela na interface gráfica é
     * atualizada para refletir as novas informações.
     * </p>
     * <p>
     * Em caso de erro durante o processo de cadastro ou atualização da tabela,
     * uma mensagem de erro é exibida ao usuário.
     * </p>
     */
    private void cadastrarChecklist() {

        // Valida se todos os campos estão preenchidos
        if (!validarCampos()) {

            return;
        }

        try {
            // Define a data atual para salvar no banco
            LocalDate hoje = LocalDate.now();
            Date dataSqlDate = Date.valueOf(hoje);

            // Cria um novo objeto DTO e define seus valores a partir da interface gráfica
            CheckListAtendimentoDTO objDTO = new CheckListAtendimentoDTO();
            objDTO.setCliente(txtCliente.getText());
            objDTO.setEmpresa(txtEmpresa.getText());
            objDTO.setStatus(cbxStatus.getSelectedItem().toString());
            objDTO.setDescricao(txtDescricao.getText());
            objDTO.setData(dataSqlDate);

            // Cria um novo objeto DAO e cadastra o checklist no banco de dados
            CheckListAtendimentoDAO objDAO = new CheckListAtendimentoDAO();
            objDAO.cadastrarChecklist(objDTO);

            // Atualiza a tabela na interface gráfica
            popularTabela();

            // Limpa os campos de texto
            limparCampos();

            // Habilita e desabilita botões
            habilitarBotoes(true, false, true, false, false, false);

        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Erro ao cadastrar checklist: " + e.getMessage(),
                    "Erro", JOptionPane.ERROR_MESSAGE);
        }
    }

    /**
     * Preenche a tabela de interface gráfica com os dados dos checklists.
     * <p>
     * Este método cria uma instância da classe {@link CheckListAtendimentoDAO}
     * para acessar o banco de dados e recuperar uma lista de objetos
     * {@link CheckListAtendimentoDTO}, representando os checklists armazenados.
     * </p>
     * <p>
     * Para cada objeto {@code CheckListAtendimentoDTO} na lista, uma nova linha
     * é adicionada à tabela na interface gráfica, exibindo os detalhes de cada
     * checklist.
     * </p>
     * <p>
     * A tabela é inicialmente limpa para garantir que apenas os dados mais
     * recentes sejam exibidos. Em caso de erro, uma mensagem de erro é exibida.
     * </p>
     */
    private void popularTabela() {
        try {
            // Cria uma instância da classe DAO para acesso aos dados do checklist
            CheckListAtendimentoDAO dao = new CheckListAtendimentoDAO();

            // Obtém o modelo da tabela e limpa as linhas existentes
            DefaultTableModel model = (DefaultTableModel) tabelaCheckList.getModel();
            model.setNumRows(0);

            // Recupera a lista de checklists do banco de dados
            List<CheckListAtendimentoDTO> lista = dao.listarChecklists();

            SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yy");

            // Itera sobre cada item da lista de checklists
            for (int num = 0; num < lista.size(); num++) {
                // Formata a data
                String dataFormatada = sdf.format(lista.get(num).getData());

                // Adiciona uma nova linha na tabela para cada item da lista
                model.addRow(new Object[]{
                    lista.get(num).getId(),
                    lista.get(num).getCliente(),
                    lista.get(num).getEmpresa(),
                    lista.get(num).getStatus(),
                    lista.get(num).getDescricao(),
                    dataFormatada // Usa a data formatada
                });
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Erro ao popular a tabela: " + e.getMessage(),
                    "Erro", JOptionPane.ERROR_MESSAGE);
        }
    }

    /**
     * Edita as informações de um Checklist selecionado na tabela.
     * <p>
     * Este método é responsável por capturar os dados da linha selecionada na
     * tabela de checklists e preencher os campos de texto do formulário com
     * estas informações, permitindo a edição.
     * </p>
     * <p>
     * <b>Fluxo de Funcionamento:</b>
     * <ul>
     * <li>Obtém o índice da linha selecionada na tabela.</li>
     * <li>Verifica se uma linha foi de fato selecionada.</li>
     * <li>Extrai os dados da linha selecionada e preenche os campos do
     * formulário.</li>
     * <li>Atualiza a interface para refletir o estado de edição.</li>
     * <li>Exibe uma mensagem caso nenhuma linha seja selecionada.</li>
     * <li>Captura e trata exceções, exibindo mensagens de erro se
     * necessário.</li>
     * </ul>
     * </p>
     * <p>
     * É importante que uma linha da tabela esteja selecionada antes da chamada
     * deste método, caso contrário, uma mensagem de informação será exibida.
     * </p>
     * <p>
     * <b>Exceções:</b>
     * Qualquer exceção capturada durante a execução é tratada internamente,
     * apresentando uma mensagem de erro ao usuário.
     * </p>
     */
    private void editarCheckList() {
        try {
            // Armazena o índice da linha que foi selecionada na tabela
            int setar = tabelaCheckList.getSelectedRow();

            // Verifica se alguma linha foi selecionada (índice diferente de -1)
            if (setar != -1) {
                // Pega os valores da linha selecionada e preenche os campos de texto correspondentes
                txtId.setText(tabelaCheckList.getModel().getValueAt(setar, 0).toString());
                txtCliente.setText(tabelaCheckList.getModel().getValueAt(setar, 1).toString());
                txtEmpresa.setText(tabelaCheckList.getModel().getValueAt(setar, 2).toString());
                cbxStatus.setSelectedItem(tabelaCheckList.getModel().getValueAt(setar, 3));
                txtDescricao.setText(tabelaCheckList.getModel().getValueAt(setar, 4).toString());

                // Atualiza os campos de texto
                habilitarCampos(true, true, true);

                // Habilita e desabilita botões
                habilitarBotoes(false, false, false, true, true, true);

            } else {

                // Caso nenhuma linha tenha sido selecionada, exibe uma mensagem de informação
                JOptionPane.showMessageDialog(null, "Favor Selecionar um Checklist!", "Informação", JOptionPane.INFORMATION_MESSAGE);
            }
        } catch (Exception e) {

            // Caso ocorra algum erro durante o processo, captura a exceção e exibe uma mensagem de erro
            JOptionPane.showMessageDialog(null, "Ocorreu um Erro ao Editar Checklist: " + e.getMessage(), "Erro", JOptionPane.ERROR_MESSAGE);
        }
    }

    /**
     * Atualiza os dados de um checklist na base de dados com as informações
     * fornecidas pela interface gráfica.
     * <p>
     * Este método realiza as seguintes etapas:
     * <ul>
     * <li>Obtém a data atual e a converte para o formato SQL.</li>
     * <li>Cria um objeto DTO ({@link CheckListAtendimentoDTO}) com os dados da
     * interface gráfica.</li>
     * <li>Utiliza um objeto DAO ({@link CheckListAtendimentoDAO}) para
     * atualizar os dados no banco.</li>
     * <li>Atualiza a tabela de exibição na interface gráfica.</li>
     * <li>Limpa os campos de entrada de dados.</li>
     * <li>Ajusta a habilitação dos botões na interface.</li>
     * </ul>
     * <p>
     * Em caso de falha (ex.: formato de dado inválido, problema de conexão com
     * o banco), exibe uma mensagem de erro.
     *
     * @throws NumberFormatException se o ID fornecido não for um número válido.
     * @throws SQLException se ocorrer um problema na conexão ou na atualização
     * do banco de dados.
     * @see CheckListAtendimentoDTO
     * @see CheckListAtendimentoDAO
     */
    private void atualizarCheckList() {

        try {

            // Define a data atual para salvar no banco
            LocalDate hoje = LocalDate.now();
            Date dataSqlDate = Date.valueOf(hoje);

            // Cria um novo objeto DTO e define seus valores a partir da interface gráfica
            CheckListAtendimentoDTO objDTO = new CheckListAtendimentoDTO();

            objDTO.setId(Integer.parseInt(txtId.getText()));
            objDTO.setCliente(txtCliente.getText());
            objDTO.setEmpresa(txtEmpresa.getText());
            objDTO.setStatus(cbxStatus.getSelectedItem().toString());
            objDTO.setDescricao(txtDescricao.getText());
            objDTO.setData(dataSqlDate);

            // Cria um novo objeto DAO e cadastra o checklist no banco de dados
            CheckListAtendimentoDAO objDAO = new CheckListAtendimentoDAO();
            objDAO.editarChecklist(objDTO);

            // Atualiza a tabela na interface gráfica
            popularTabela();

            // Limpa os campos de texto
            limparCampos();

            // Habilita e desabilita botões
            habilitarBotoes(true, false, true, false, false, false);

        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Erro ao editar checklist: " + e.getMessage(),
                    "Erro", JOptionPane.ERROR_MESSAGE);
        }
    }

    /**
     * Exclui um checklist específico da base de dados.
     * <p>
     * Este método executa uma operação SQL de DELETE para remover um checklist
     * baseado em seu ID. É importante que o ID fornecido corresponda a um
     * checklist existente na base de dados.
     * <p>
     * Passos executados:
     * <ul>
     * <li>Estabelece uma conexão com o banco de dados.</li>
     * <li>Prepara uma instrução SQL de DELETE com o ID fornecido.</li>
     * <li>Executa a instrução e verifica se algum registro foi afetado.</li>
     * <li>Exibe uma mensagem ao usuário informando sobre o sucesso ou falha da
     * operação.</li>
     * </ul>
     * <p>
     * Em caso de exceção (como problemas de conexão ou SQL inválido), uma
     * mensagem de erro é exibida.
     *
     * @param idChecklist O ID do checklist a ser excluído.
     * @throws SQLException Se ocorrer algum problema durante a execução da
     * query SQL ou conexão com o banco.
     * @see PreparedStatement
     * @see Connection
     */
    private void excluirCheckList() {

        try {
            int id = Integer.parseInt(txtId.getText()); // Tenta converter o texto para um inteiro

            CheckListAtendimentoDTO objDTO = new CheckListAtendimentoDTO();
            objDTO.setId(id);

            CheckListAtendimentoDAO objDAO = new CheckListAtendimentoDAO();
            objDAO.excluirChecklist(objDTO);

            // Atualiza a tabela na interface gráfica
            popularTabela();

            // Reseta os campos de texto
            limparCampos();

            // Desabilita os campos de texto
            habilitarCampos(false, false, false);

            // Atualiza o estado dos botões
            habilitarBotoes(true, false, true, false, false, false);

        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Formato de número inválido: " + e.getMessage(), "Erro", JOptionPane.ERROR_MESSAGE);
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Erro ao excluir centro de custo: " + e.getMessage(), "Erro", JOptionPane.ERROR_MESSAGE);
        }
    }

    /**
     * Filtra e exibe na tabela os checklists com base no status selecionado.
     * <p>
     * Este método realiza as seguintes operações:
     * <ul>
     * <li>Cria uma instância de {@link CheckListAtendimentoDAO} para acessar os
     * dados de checklists.</li>
     * <li>Limpa as linhas existentes na tabela de checklists.</li>
     * <li>Obtém o status selecionado no ComboBox da interface do usuário.</li>
     * <li>Recupera do banco de dados uma lista de checklists que correspondem
     * ao status selecionado.</li>
     * <li>Itera sobre a lista de checklists, formatando a data e adicionando
     * cada checklist como uma nova linha na tabela.</li>
     * </ul>
     * <p>
     * Em caso de exceção, exibe uma mensagem de erro para o usuário.
     * <p>
     * Usa {@link SimpleDateFormat} para formatar a data dos checklists para o
     * formato dd/MM/yy antes de exibi-los na tabela.
     *
     * @throws Exception Se ocorrer um erro durante a obtenção dos dados ou ao
     * popular a tabela.
     */
    private void filtrarTabelaPorSatatus() {
        try {
            // Cria uma instância da classe DAO para acesso aos dados do checklist
            CheckListAtendimentoDAO dao = new CheckListAtendimentoDAO();

            // Obtém o modelo da tabela e limpa as linhas existentes
            DefaultTableModel model = (DefaultTableModel) tabelaCheckList.getModel();
            model.setNumRows(0);

            // Obtém o status selecionado no ComboBox e recupera do banco de dados a lista de checklists que correspondem ao status selecionado
            List<CheckListAtendimentoDTO> lista = dao.listarChecklistsPorStatus(cbxStatus.getSelectedItem().toString());

            SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yy");

            // Itera sobre cada item da lista de checklists
            for (int num = 0; num < lista.size(); num++) {
                // Formata a data
                String dataFormatada = sdf.format(lista.get(num).getData());

                // Adiciona uma nova linha na tabela para cada item da lista
                model.addRow(new Object[]{
                    lista.get(num).getId(),
                    lista.get(num).getCliente(),
                    lista.get(num).getEmpresa(),
                    lista.get(num).getStatus(),
                    lista.get(num).getDescricao(),
                    dataFormatada // Usa a data formatada
                });
            }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Erro ao popular a tabela: " + e.getMessage(),
                    "Erro", JOptionPane.ERROR_MESSAGE);
        }
    }

    /**
     * Configura a habilitação de botões na interface gráfica.
     * <p>
     * Este método é utilizado para controlar o estado de habilitação de vários
     * botões na interface gráfica, como Novo, Salvar, Editar, Atualizar,
     * Excluir e Cancelar. Cada parâmetro booleano passado ao método determina
     * se o respectivo botão será habilitado (true) ou desabilitado (false).
     * </p>
     * <p>
     * Isso é útil para gerenciar o fluxo de interação do usuário com a
     * aplicação, permitindo ou restringindo ações com base no estado atual da
     * aplicação ou em regras de negócio específicas.
     * </p>
     *
     * @param novo Define se o botão Novo será habilitado (true) ou desabilitado
     * (false).
     * @param salvar Define se o botão Salvar será habilitado (true) ou
     * desabilitado (false).
     * @param editar Define se o botão Editar será habilitado (true) ou
     * desabilitado (false).
     * @param atualizar Define se o botão Atualizar será habilitado (true) ou
     * desabilitado (false).
     * @param excluir Define se o botão Excluir será habilitado (true) ou
     * desabilitado (false).
     * @param cancelar Define se o botão Cancelar será habilitado (true) ou
     * desabilitado (false).
     */
    private void habilitarBotoes(boolean novo, boolean salvar, boolean editar, boolean atualizar, boolean excluir, boolean cancelar) {
        btnNovo.setEnabled(novo);
        btnSalvar.setEnabled(salvar);
        btnEditar.setEnabled(editar);
        btnAtualizar.setEnabled(atualizar);
        btnExcluir.setEnabled(excluir);
        btnCancelar.setEnabled(cancelar);
    }

    /**
     * Limpa os campos de entrada de dados na interface gráfica.
     * <p>
     * Este método é responsável por resetar os campos de texto e seleção na
     * interface gráfica, estabelecendo-os para seus valores padrão ou vazios.
     * Ele é utilizado para preparar a interface para uma nova entrada de dados,
     * como após a conclusão de uma operação de cadastro, edição ou
     * cancelamento.
     * </p>
     * <p>
     * Os campos afetados incluem o campo de texto do cliente, o campo de texto
     * da empresa, a caixa de combinação de status (definida para um valor
     * padrão de "Selecione"), e o campo de texto da descrição.
     * </p>
     */
    private void limparCampos() {
        txtCliente.setText("");
        txtEmpresa.setText("");
        cbxStatus.setSelectedItem("Selecione");
        txtDescricao.setText("");
    }

    /**
     * Habilita ou desabilita a edição de campos de texto na interface gráfica.
     * <p>
     * Este método é usado para controlar a editabilidade dos campos de texto na
     * interface gráfica, especificamente os campos relacionados a cliente,
     * empresa e descrição. A editabilidade de cada campo é controlada por um
     * parâmetro booleano correspondente, onde {@code true} habilita a edição do
     * campo e {@code false} a desabilita.
     * </p>
     * <p>
     * Isso é útil para restringir a entrada de dados do usuário em certos
     * momentos do fluxo de operação da aplicação, como durante a visualização
     * de detalhes de um registro, onde a edição pode não ser permitida.
     * </p>
     *
     * @param cliente Define a editabilidade do campo de texto do cliente.
     * {@code true} para habilitar, {@code false} para desabilitar.
     * @param empresa Define a editabilidade do campo de texto da empresa.
     * {@code true} para habilitar, {@code false} para desabilitar.
     * @param descricao Define a editabilidade do campo de texto da descrição.
     * {@code true} para habilitar, {@code false} para desabilitar.
     */
    private void habilitarCampos(boolean cliente, boolean empresa, boolean descricao) {

        txtCliente.setEditable(cliente);
        txtEmpresa.setEditable(empresa);
        txtDescricao.setEditable(descricao);
    }

    /**
     * Valida se os campos obrigatórios da interface de usuário foram
     * preenchidos.
     * <p>
     * Este método verifica se os campos de texto para Cliente, Empresa e
     * Descrição estão preenchidos e se um status válido foi selecionado. Se
     * algum dos campos estiver vazio ou se o status selecionado for o valor
     * padrão "Selecione", uma mensagem de erro é exibida e o método retorna
     * {@code false}.
     * <p>
     * Utiliza a função {@code trim()} para remover espaços em branco
     * desnecessários no início e no final dos campos de texto.
     * <p>
     * Este método é tipicamente usado para validar a entrada do usuário antes
     * de realizar operações como salvar ou atualizar registros.
     *
     * @return {@code true} se todos os campos obrigatórios estiverem
     * preenchidos corretamente, caso contrário {@code false}.
     */
    private boolean validarCampos() {

        if (txtCliente.getText().trim().equals("") || txtEmpresa.getText().trim().equals("")
                || cbxStatus.getSelectedItem().equals("Selecione") || txtDescricao.getText().trim().equals("")) {
            JOptionPane.showMessageDialog(null, "Favor preencher todos os campos!", "Informação", JOptionPane.INFORMATION_MESSAGE);
            return false;
        }

        return true;
    }

    /**
     * Aplica a regra de filtro na tabela com base no status selecionado.
     * <p>
     * Este método verifica se o botão de rádio para filtro está selecionado e
     * se um status válido (diferente de "Selecione") foi escolhido no ComboBox.
     * Dependendo dessas condições, diferentes métodos de filtragem ou de
     * povoamento da tabela são chamados:
     * <ul>
     * <li>Se o filtro estiver ativado e um status válido selecionado, a tabela
     * é filtrada pelo status.</li>
     * <li>Caso contrário, a tabela é populada com todos os registros
     * disponíveis.</li>
     * </ul>
     * <p>
     * Utiliza os métodos {@link #filtrarTabelaPorStatus()} e
     * {@link #popularTabela()} para realizar as operações de filtragem e
     * povoamento.
     */
    private void regraFiltro() {

        if (rdbFiltro.isSelected() && !cbxStatus.getSelectedItem().equals("Selecione")) {

            filtrarTabelaPorSatatus();

        } else {

            popularTabela();
        }
    }

    /**
     * Aplica um filtro que transforma automaticamente o texto em maiúsculas nos
     * campos de texto.
     * <p>
     * Este método configura um {@link UpperCaseDocumentFilter} para os campos
     * de texto txtCliente, txtEmpresa, e txtDescricao. Com este filtro,
     * qualquer texto digitado nesses campos será convertido para maiúsculas,
     * melhorando a consistência dos dados inseridos.
     * <p>
     * O filtro é aplicado diretamente ao {@link AbstractDocument} de cada
     * {@link JTextField}, garantindo que a transformação ocorra no momento da
     * digitação pelo usuário.
     *
     * @see UpperCaseDocumentFilter
     */
    private void aplicarFiltroMaiusculas() {
        AbstractDocument docCliente = (AbstractDocument) txtCliente.getDocument();
        docCliente.setDocumentFilter(new UpperCaseDocumentFilter());

        AbstractDocument docEmpresa = (AbstractDocument) txtEmpresa.getDocument();
        docEmpresa.setDocumentFilter(new UpperCaseDocumentFilter());

        AbstractDocument docDescricao = (AbstractDocument) txtDescricao.getDocument();
        docDescricao.setDocumentFilter(new UpperCaseDocumentFilter());
    }

}
